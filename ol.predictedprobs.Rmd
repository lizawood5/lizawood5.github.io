---
title: "Ordered Logits: Predicted probabilities with `polr` and `vglm`"
subtitle: "Understanding different model objects in the `predict` function"
---


To generate predicted probabilities, create a data frame from your original data for all of the independent variables. One quick way of creating profiles it to set all independent variables to their median, except for one which can be represented across its range of values. In our case, we will hold all else constant except for economic values.
```{r models}
polr.model <- polr(interest ~ acres + income + education + econ.value + 
                     envt.value + info.count, data = df, Hess = T) 
# We use Hess = T in order to return the Hessian matrix, which allows us to look at the model's summary
summary(polr.model)
```



```{r predicted probs}
pp_df = with(df, data.frame(acres = median(acres, na.rm = T), income = median(income, na.rm = T), education = median(education, na.rm = T), econ.value = c(1:5), envt.value = median(envt.value, na.rm = T), info.count = median(info.count, na.rm = T)))
```

The beauty of the `polr` model is that it is compatible with the "prob" type in the `predict` function to automatically generate predicted probabilities for the profiles defined in the previous dataframe creation.

```{r predict function}
pp <- cbind(pp_df, predict(polr.model, newdata = pp_df, type = "prob", se.fit = T)); pp
```

## Here is an important bit
# With ordered in polr or multinom, the type = "probs" and you can do se=TRUE
# With vglm you go back to EITHER "response" or "link", 
# Response will more readily give you predicted probabilities, but not the se, 
# Link gives you fitted values, and everything needs to be converted 
# I have been going with the type = "link", se=TRUE, then using the following manipulations

```{r}
vgam.model.nonprop <- vglm(ordered(interest) ~ acres + income + education + 
                            econ.value + envt.value + info.count,  data = df, 
                          family=cumulative(parallel = F, reverse = T))
```

```{r}
pp = cbind(pp_df, predict(vgam.model.nonprop, newdata = pp_df, type = "link", se=TRUE))
```
# By using the link type, instead of response or probs, you get fitted values of each step, instead of predicted probabilities outright. So then some manipulation...

# In this next step, YOU WILL NEED TO CHANGE THESE COLUMN NAMES based on the link function of your partial prop model. What I am going to show is the link functions for the SNP model. You will just have to plug in column names that work for you to assign to the fit objects.

colnames(pp_pred_snp)

# This just isolates each list of fittes values and SEs. If you have more than 3 levels (and therefore 2 fitted values/SEs, you will just duplicate this process)
fit1 = pp$`fitted.values.logitlink(P[Y>1|Y>=1])`
fit2 = pp$`fitted.values.logitlink(P[Y>2|Y>=2])`
se.fit1 = pp$`se.fit.logitlink(P[Y>1|Y>=1])`
se.fit2 = pp$`se.fit.logitlink(P[Y>2|Y>=2])`

# here we convert fitted values into confidence intervals 
# Here I take the opportunity to name my levels Conceptual and Applied
ppdf_predCIs <- within(pp, {
  Conceptual <- plogis(fit1)
  LL1 <- plogis(fit1 - (1.96 * se.fit1))
  UL1 <- plogis(fit1 + (1.96 * se.fit1))
  Applied <- plogis(fit2)
  LL2 <- plogis(fit2 - (1.96 * se.fit2))
  UL2 <- plogis(fit2 + (1.96 * se.fit2))
})

# Here I am just melting the DF to get the predicted probs with the upper and lower limits all aligned
meltdf = ppdf_predCIs %>% gather(key = "Level", value = "Probability", Conceptual, Applied, -UL1, -LL1, -UL2, -LL2) %>% gather(key = "ULCI", value = "ULvalue", UL1, UL2, -Level, -Probability, -LL1, -LL2) %>% gather(key = "LLCI", value = "LLvalue", LL1, LL2, -Level, -Probability, -ULCI, -ULvalue) 

# I don't remember why I did this, but I did...
meltdf1 = meltdf %>% filter(Level == "Conceptual" & ULCI == "UL1" & LLCI == "LL1")
meltdf2 = meltdf %>% filter(Level == "Applied" & ULCI == "UL2" & LLCI == "LL2")
meltdf.clean = rbind(meltdf1, meltdf2)

# Snagged and adopted plotting code from here
# https://stats.idre.ucla.edu/r/dae/multinomial-logistic-regression/
meltdf.clean$Level = ordered(meltdf.clean$Level, levels=c("Conceptual","Applied"))
pd = position_dodge(.1)
ggplot(meltdf.clean, aes(x=blame_ag, y=Probability, ymin=LLvalue, ymax=ULvalue)) + 
  geom_ribbon(alpha=0.2) +
  geom_line(size=0.2) + facet_wrap(~Level) +
  labs(x = "Blames ag. N sources", y = "Predicted probabilities", title = "Nitrogen Management Plan") + scale_fill_brewer() + theme_classic() + theme(text= element_text(size=10, family="Times"), plot.title = element_text(hjust = .5, vjust = 0, size = 10), strip.background  = element_blank())

# Also for first differences, you can quickly compare 1st and 3rd quatriles to talk about "profiles"
summary(modeldf.naomit$blame_ag)
pp_quartiles = ppdf_predCIs %>% dplyr::select(blame_ag, Conceptual, Applied) %>% filter(blame_ag == 3 | blame_ag == 4)




## In case you want to play with other variables, there are there rep() functions with length and each arguements I always found to be finnicky.

# For example, if I want to see the predicted probs (eventually) for different income ranges AND dfferent conservaton values together, I would think: 6 income levels and 5 value scores, so the length of this df will be 30. So you can choose either variable to use the "legnth" or the "each" argument. It will only vary in how they repeat. But one can get the length, so income will repeat 1-6 until the length of 30, which will be a total of 5 cycles. Then conservation will repeat 1:5, but each will be repeated 6 times, it 1,1,1,1,1,1,2,2,2,2,2,2.... That way you get all possible combinations of income and conservation values in your various predicted props.
long_df = with(df, data.frame(LogTotalFarm_acres = median(LogTotalFarm_acres, na.rm = T), income = rep(c(1:6), length.out = 30), Education2 = median(Education2, na.rm = T), blame_ag = median(blame_ag, na.rm = T), priority_econ = median(priority_econ, na.rm = T), priority_conservation = rep(c(1:5), each = 6), Info_count_15 = median(Info_count_15, na.rm = T), Q17_SelfCert_A = 1, wqcperc_avg = median(wqcperc_avg, na.rm = T)))



